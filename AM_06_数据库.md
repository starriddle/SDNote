# 上午题 06 数据库

<!-- TOC -->

- [上午题 06 数据库](#上午题-06-数据库)
  - [说明](#说明)
  - [概念数据模型](#概念数据模型)
  - [结构数据模型](#结构数据模型)
  - [三级模式结构](#三级模式结构)
  - [关系模型的基本术语](#关系模型的基本术语)
  - [关系模型定义](#关系模型定义)
    - [关系数据结构](#关系数据结构)
    - [关系操作集合](#关系操作集合)
    - [完整性约束](#完整性约束)
  - [关系代数](#关系代数)
  - [关系代数转SQL语言](#关系代数转sql语言)
  - [SQL语言概述](#sql语言概述)
    - [数据定义语言](#数据定义语言)
    - [数据操纵语言](#数据操纵语言)
    - [数据查询语言](#数据查询语言)
      - [投影查询](#投影查询)
      - [选择查询](#选择查询)
      - [排序查询](#排序查询)
      - [聚合函数](#聚合函数)
      - [数据分组](#数据分组)
      - [连接查询](#连接查询)
        - [内连接](#内连接)
        - [外连接](#外连接)
      - [一般子查询](#一般子查询)
        - [一般子查询](#一般子查询-1)
        - [相关子查询](#相关子查询)
        - [EXISTS子查询](#exists子查询)
      - [查询结果并、交、差运算](#查询结果并交差运算)
    - [SQL控制语句](#sql控制语句)
    - [视图](#视图)
    - [索引](#索引)
  - [关系模式](#关系模式)
  - [函数依赖](#函数依赖)
    - [函数依赖的公理系统(Armstrong公理系统)](#函数依赖的公理系统armstrong公理系统)
    - [属性闭包计算](#属性闭包计算)

<!-- /TOC -->

## 说明

- 分值：6分
- 分布：51-56

教程 9 数据库基础知识 P455-P516

关系代数
SQL语言
关系模式
范式
关系分解：无损连接、函数依赖

- 数据模型分类
  - 概念数据模型
  - 结构数据模型

## 概念数据模型

常用术语

- 实体：客观存在并可以相互区别的事物称为实体
- 属性：描述实体的特性称为属性，一个实体可以由若干个属性来刻画
- 码：唯一标识实体的属性集称为码
- 域：属性的取值范围称为该属性的域
- 实体型：具有相同属性的实体必然具有共同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体，称为实体型
- 实体集：同型实体的集合称为实体集
- 联系：实体（型）之间的对应关系称为联系
  - 实体内部各属性之间的联系
  - 实体之间的联系
  - 实体型之间的联系类型：
    - 一对一联系（1:1）
    - 一对多联系（1:n）
    - 多对多联系（m:n）

实体-联系方法表示的概念数据模型称为 E-R 图

E-R 图是抽象和描述现实世界的有力工具，它提供了表示实体型、属性和联系的方法

实体型 - 矩形
属性 - 椭圆形
联系 - 菱形

## 结构数据模型

- 结构数据模型是直接面向数据库的逻辑结构
- 任何一个DBMS都以某个结构数据模型为基础
- 常用术语
  - 数据项/字段：
    - 数据库中可以命名的最小逻辑数据单位
    - 可以是一个数或一个字符串，用它描述属性的数据
  - 记录：
    - 数据项的有序集
    - 一个记录是由若干个数据项或字段组成，用它描述实体
  - 文件：
    - 一个具有符号名的一组同类记录的集合
    - 文件包含了记录的结构和记录的值
- 分类
  - 层次模型
    - 用“树结构”表示数据之间的联系
    - 数据库系统最早使用的模型
    - 数据结构是一棵“有向树”
    - 特征：
      - 有且仅有一个结点没有父结点，它就是根结点
      - 其他结点有且仅有一个父结点
  - 网状模型
    - 用“图结构”表示数据之间的联系
    - 网中的每一个结点代表一个记录型，联系用链接指针来实现
    - 特征：
      - 允许结点有多于一个的父结点
      - 可以有一个以上的结点没有父结点
  - 关系模型
    - 用二维表格结构来表示实体以及实体之间联系
    - 每个二维表由行、列组成，又可称为关系，关系模式是对关系的描述
    - 关系模型是由关系模式组成的集合
    - 目前主流的数据模型，大多数数据库管理系统都是关系型的
    - 特征：
      - 描述的一致性，不仅用关系描述实体本身，而且也用关系描述实体之间的联系
      - 可直接表示多对多的联系
      - 关系必须是规范化的关系，即每个属性是不可分的数据项，不允许表中有表
      - 关系模型是建立在数学概念基础上的，有较强的理论根据
    - 关系模型中，基本数据结构就是二维表
    - 记录之间的联系通过不同关系中的同名属性来体现
  - 面向对象模型

## 三级模式结构

不同的数据库，建立在不同的操作系统上，使用不同的数据库语言，支持不同的数据模型，数据的存储结构也各不相同，但体系结构基本上都具有相同的特征，采用“三级模式和两级映像”。

**三级模式结构**：数据库管理系统内部的系统结构

- 概念模式
  - 也称 模式
  - 是 数据库中全体数据的逻辑结构和特征的描述
  - 由若干个概念记录类型组成，只涉及型的描述，不涉及具体的值
  - 对应“基本表”
- 外模式
  - 也称 用户模式/子模式
  - 是 用户与数据库系统的接口
  - 是用户用到的那部分数据的描述，由若干个外部记录类型组成
  - 对应“视图”
- 内模式
  - 也称 存储模式
  - 是 数据物理结构和存储方式的描述
  - 是数据在数据库内部的表示方式，定义所有的内部记录类型、索引和文件的组织方式以及数据控制方面的细节
  - 对应“存储文件”

**两级映像**：数据库系统在三级模式之间提供了两级映像

- 模式/内模式映像
  - 该映像存在于 概念级和内部级 之间，实现了 概念模式到内模式 之间的相互转换。
  - 物理独立性
- 外模式/模式映像
  - 该映像存在于 外部级和概念级 之间，实现了 外模式到概念模式 之间的相互转换。
  - 逻辑独立性

## 关系模型的基本术语

关系数据库系统是支持关系模型的数据库系统，关系模型的一些基本术语：

- 关系：一个关系就是一张二维表，每个关系有一个关系名
- 元组：表中的一行即为一个元组，对应存储文件中的一个记录值。
- 属性：表中的列称为属性，每一列有一个属性名。属性值相当于记录中的数据项或者字段值。
- 域：属性的取值范围。
- 关系模式：对关系的描述称为关系模式，由关系名和其属性集合构成。
  - 关系模式的格式为：`关系名(属性名1,属性名2,...,属性名n)`
  - 通常一个关系模式对应一个关系文件的结构
- 候选码(候选键)：属性或属性组合，其值能够唯一地标识一个元组。
- 主码(主键)：在一个关系中可能有多个候选码，从中选择一个作为主码。
- 主属性：包含在任何候选码中的诸属性称为主属性，不包含在任何候选码中的诸属性称为非码属性
- 外码(或外键)：如果一个关系中的属性或属性组并非该关系(二维表)的码，但它们是另外一个关系(二维表)的码，则称其为该关系的外码。
- 全码：关系模式的所有属性组是这个关系模式的候选码，称为全码。
- 超码(超键)：一个包含码的属性集称为超码。

## 关系模型定义

关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成

### 关系数据结构

关系模型中数据的逻辑关系是一张二维表格

### 关系操作集合

常用关系操作：选择、投影、连接、除、并、交、差等查询操作和增加、删除操作等

### 完整性约束

完整性规则保证用户对数据库做修改时不会破坏数据的一致性。

- 实体完整性：关系中主码的值不能为空或部分为空。即主属性不能为空。
- 参照完整性：如果关系R2的外码X与关系R1的主码相对应，则外码X的每个值必须在关系R1中的主码中找到，或者为空值。
- 用户定义完整性：指用户对某一具体数据指定的约束条件进行检验。(如手机号码为11位)

## 关系代数

集合的笛卡尔积：D₁×D₂×...×Dₙ = {(d₁,d₂,...,dₙ)|dᵢ∈Dᵢ,i=1,2,...,n}

![alt text](./AM_06_01.png)

- 传统的集合运算
  - 关系的并：关系R、S的所有元组合并，删去重复的的元组，组成一个新关系
  - 关系的差：关系R、S的差由属于R而不属于S的所有元组组成的集合
  - 关系的交：关系R、S的交由既属于R又属于S的所有元组组成的集合
  - 笛卡尔积：类似于集合的笛卡尔积，关系的元组代替集合的元素
- 专门的关系运算符
  - 投影(Projection)：从关系的垂直方向进行运算，在关系R中选择出若干属性列A组成新的关系。记作πᴀ(R)={t[A]|t∈R}
  - 选择(Selection)：从关系的水平方向进行运算，从关系R中选择满足给定条件的的元组，记作σꜰ(R)={t|t∈R 并且 F(t)=True}
  - 连接(Join)：从两个关系R和S的笛卡儿积中选取满足条件的元组。
    - θ连接：从R与S的笛卡儿积中选取属性间满足一定条件的元组。
    - 等值连接：当 θ 为 “=” 时，称之为等值连接。
    - 自然连接 ⋈：自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果集中将重复属性列去掉。
    > 可以认为笛卡儿积是无条件连接，其他的连接操作认为是有条件连接。
  - 外连接(Outer Join)：外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息。(p27集)
    - 左外连接(Left Outer Join ⟕)：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值null充填所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中。
    - 右外连接( Right Outer Join ⟖)：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值null填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中。
    - 全外连接(Full Outer Join ⟗)：完成左外连接和右外连接的操作。即填充左侧关系中所有与右侧关系中任一元组都不匹配的元组，并填充右侧关系中所有与左侧关系中任一元组都不匹配的元组，将产生的新元组加入自然连接的结果中。
  - 除(Division)：同时从关系的水平方向和垂直方向进行运算。给定关系R(X,Y)和S(Y,Z),X、Y、Z为属性组，R÷S应当满足元组在X上的分量值x的象集Yₓ包含关系S在属性组Y上的投影的集合。

## 关系代数转SQL语言

> SQL 语言不支持列的序号

给定关系 R(A,B,C) 和 S(B,C,D)

- 投影
  - πᴀ(R)={t[A]|t∈R}
  - select A from R
- 选择
  - σꜰ(R)={t|t∈R 并且 F(t)=True}
  - select A,B,C from R where F(t)=True
- 笛卡尔积
  - π(R×S)
  - select R.A,R.B,R.C,S.B,S.C,S.D from R,S
- 自然连接
  - $R⋈S = π_{R.A,R.B,R.C,S.D}(σ_{R.B=S.B∧R.C=S.C}(R×S))$
  - select R.A,R.B,R.C,S.D from R,S where R.B=S.B and R.C=S.C

## SQL语言概述

**特点**：

- 类似于英语自然语言、简单易学
- 一种非过程语言
- 一种面向集合的语言
- 既可独立使用，又可嵌入到宿主语言中使用
- 具有查询、操纵、定义和控制一体化功能

**SQL Server 数据库体系结构**：

- 由视图、基本表和存储文件三级结构组成
  - 即外模式、概念模式、内模式
- 一个数据库是表的汇集，它用一个关系模型定义一个基本表或视图
- 基本表是存储在数据库中的表，视图是由若干个基本表或其他视图构成的表，称为虚表
- 一个基本表可以跨一个或多个存储文件，一个存储文件可以存放一个或多个基本表
- 每个存储文件与外部存储器上的一个物理文件对应

**SQL 语言分类**：

- DDL
  - 数据定义语言，Data Definition Language
  - 建立、修改、删除数据库对象(数据库、表、视图、索引等)
  - CREATE、ALTER、DROP 等
- DML
  - 数据操纵语言，Data Manipulation Language
  - 添加、修改、删除数据库数据
  - INSERT、UPDATE、DELETE 等
- DQL
  - 数据查询语言，Data Query Langague
  - 查询数据库数据，是数据库的基本功能
  - SELECT
- DCL
  - 数据控制语言，Data Control Language
  - 包括数据库对象的权限管理和事务管理等

### 数据定义语言

建立数据库

```sql
CREATE DATABASE <数据库名>
```

建立基本表

```sql
CREATE TABLE <表名>(
  <列名> <数据类型> [列级完整性约束条件]
  [,<列名> <数据类型> [列级完整性约束条件]]...
  [,表级完整性约束条件]...
);
```

- 完整性约束
  - 主要有3种子句：
    - 主键子句(PRIMARY KEY)
      - 实体完整性
    - 检查子句(CHECK)
      - 用户自定义完整性
    - 外键子句(FOREIGN KEY)
      - 参照完整性
  - 其他
    - 非空：NOT NULL
    - 唯一：UNIQUE
    - 默认值：DEFAULT

修改基本表结构

```sql
-- 增加新列
ALTER TABLE <表名> ADD <列名> <数据类型> [列级完整性约束条件]

-- 修改新列
ALTER TABLE <表名> MODIFY <列名> <新数据类型>

-- 删除列
ALTER TABLE <表名> DROP <完整性约束名>
```

删除基本表

```sql
DROP TABLE <表名>
```

### 数据操纵语言

插入

```sql
INSERT INTO <表名>(列名序列) VALUES(元组值)
INSERT INTO <表名>(列名序列) SELECT 查询语句
```

删除

```sql
DELETE FROM <表名> [WHERE 条件表达式]
```

修改

```sql
UPDATE <表名> SET <列名>=值表达式[, <列名>=值表达式]... [WHERE 条件表达式]
```

### 数据查询语言

SELECT 语句

```sql
SELECT [ALL|DISTINCT] <目标列表达式>[, <目标列表达式>]...
FROM <表名>[, <表名>]
[WHERE <条件表达式>]
[GROUP BY <列名1> [HAVING <条件表达式>]]
[ORDER BY <列名2> [ASC|DESC]...]
```

#### 投影查询

- SELECT 子句可以选则查询表中的任意列
- FROM 子句指明从什么表中提取数据
- DISTINCT 去重：去除重复的显示数据行
- AS 别名关键字：<列名> AS <别名>

#### 选择查询

- 指定查询条件，只从源表提取满足该查询条件的记录
- WHERE 子句的行条件表达式指出记录应满足的条件
- 运算类型
  - 条件表达式的比较运算
  - 字符串的匹配运算：`[NOT] LIKE <匹配串>`
    - %：代表任意长度的字符串
    - _：代表任意单个字符
  - 集合的比较运算：条件表达式中包含集合成员运算符
  - 逻辑组合运算：条件表达式中包含多个条件子句，通过逻辑运算符组合

#### 排序查询

- 使用 ORDER BY 子句来控制选择行的显示顺序
- ORDER BY 子句必须是 SELECT 语句中的最后一个子句

#### 聚合函数

- 实现数据统计等功能
  - 对一组值进行计算并返回一个单一的值
- 在 select 子句中的 目标列表达式 中使用
- 通常与 group by 子句一起使用，对每个分组进行数据统计
  - 无 GROUP BY 子句，聚合函数的作用范围是满足 WHERE 子句条件的所有记录
  - 有 GROUP BY 子句，聚合函数的作用范围是对结果进行分组后每组的所有记录
- 聚合函数参数一般格式：`[ALL|DISTINCT] expr`，默认为 `ALL`

#### 数据分组

- 使用 GROUP BY 子句把查询结果按指定列分成集合组
- 使用 HAVING 子句定义这些组必须满足的条件，满足条件的分组才会出现在结果中
- WHERE + GROUP BY + HAVING + 聚合函数
  - 执行 WHERE 子句，提取符合条件的记录
  - 执行 GROUP BY 子句，对记录进行分组
  - 执行聚合函数
  - 执行 HAVING 子句，筛选符合条件的分组

#### 连接查询

一个查询中需要对多个表连接时，可以指定连接列，在 WHERE 子句中给出连接条件，在 FROM 子句中指定要连接的表

```sql
SELECT 列名1, 列名2, ... FROM 表1, 表2, ... WHERE 连接条件 AND 查询条件
```

连接分为内连接（INNER JOIN）和外连接（OUTER JOIN），一般的连接查询（不使用关键字）默认为内连接

##### 内连接

最基本的连接方式

```sql
SELECT 列名1, 列名2, ... FROM 表1 INNER JOIN 表2 ON 连接条件 WHERE 查询条件
```

- 等值连接
  - 表之间通过等于关系连接起来，产生一个连接临时表，进行处理并生成结果
- 非等值连接
  - 表之间的连接关系不是等于，而是其他关系
- 自连接
  - 将同一个表进行连接，如同两个分开的表一样，将同一个表的不同行连接起来

##### 外连接

```sql
SELECT 列名1, 列名2, ... FROM 表1 (LEFT|RIGHT|FULL) [OUTER] JOIN 表2 ON 连接条件 WHERE 查询条件
```

- 左外连接
  - 左连接的结果包括表1所有行，不包括表2中的不匹配行
- 右外连接
  - 右连接的结果包括表2所有行，不包括表1中的不匹配行
- 全外连接
  - 全连接的结果包括2个表的所有行，即包括2个表中的所有不匹配行

#### 一般子查询

当一个查询是另一个查询的条件时，即当从表中选取数据行的条件依赖于该表本身或其他表的联合信息时，需要使用子查询来实现。

子查询可以使用几个简单命令构造功能强大的复杂命令。

子查询常用于 SELECT 语句的 WHERE 子句中，即在一个 SELECT 语句的 WHERE 子句中嵌套另一个 SELECT 语句。

##### 一般子查询

- 每个子查询仅执行一次
- 子查询独立完成，与主查询无关
- 子查询返回值由主查询的 WHERE 子句所用

##### 相关子查询

内层的查询条件涉及到外层属性的子查询，称为相关子查询

- 子查询不止执行一次，在主查询判断每一行时，都会唤醒子查询
- 主查询会将当前行的某些属性提交给子查询，用于子查询的查询条件
- 子查询返回值提交给主查询，用于判断当前行是否满足条件
- 相关子查询比较费时，不建议对较大的表使用

##### EXISTS子查询

- 在子查询中使用 EXISTS 关键字，其后紧跟一个 SELECT 子查询
  - 子查询一般用在 WHERE 子句中
  - EXISTS 代表存在量词
- 带有 EXISTS 谓词的子查询不返回任何数据，只返回逻辑真和假
  - 当子查询结果不为空集时返回逻辑真，否则返回逻辑假

#### 查询结果并、交、差运算

可以使用以下运算符将多个 SELECT 语句的结果进行相应运算：

- 运算符：
  - UNION：并
  - INTERSECT：交
  - EXCEPT：差
- 说明：
  - 用于运算的所个 SELECT 语句的结果列必须一致
  - 整个语句最后的 ORDER BY 子句可对运算结果进行排序

### SQL控制语句

- 数据控制控制的是用户对数据的存储权利，是由DBA决定的
- 某个用户对某类数据具有何种权力，是个政策问题，而非技术问题，基于安全性
- DBMS的功能是保证这些决定的执行，因此 DBMS 数据控制应具有以下功能
  - 通过 GRANT 和 REVOKE 将授权通知系统，存入数据字典
  - 当用户提出请求时，根据授权情况检查是否执行操作请求

授权

```sql
GRANT <权限1>[(<列1>[,<列2>]...)][,<权限2>[(<列1>[,<列2>]...)]]... [ON <对象类型> <对象名>] TO (PUBLIC|<用户1>[,<用户2>]...) [WITH GRANT OPTION]
```

收回权限

```sql
REVOKE <权限1>[(<列1>[,<列2>]...)][,<权限2>[(<列1>[,<列2>]...)]]... [ON <对象类型> <对象名>] FROM (PUBLIC|<用户1>[,<用户2>]...)
```

常见操作权限（不同类型的操作对象有不同的操作权限）

|  对象  | 对象类型 | 操作权限                                                                     |
| :----: | :------: | ---------------------------------------------------------------------------- |
| 属性列 |  TABLE   | SELECT, INSERT,UPDATE, DELETE, ALL PRIVILEGES（4种权限的总和）               |
|  视图  |  TABLE   | SELECT, INSERT,UPDATE, DELETE, ALL PRIVILEGES（4种权限的总和）               |
| 基本表 |  TABLE   | SELECT, INSERT,UPDATE, DELETE, ALTER, INDEX, ALL PRIVILEGES（6种权限的总和） |
| 数据库 | DATABASE | CREATETAB 建立表的权限，可由 DBA 授予普通用户                                |

说明

- PUBLIC：接收权限的用户可以是单个或多个具体的用户，PUBLIC 参数可将权限赋予全体用户
- WITH GRANT OPTION：获得了权限的用户还可以使用 GRANT 语句将所得权限赋予其他用户
- 对属性列的操作权限进行授权/收回时，指定属性列需要紧接在指定权限后
  - 例：`REVOKE UPDATE(no, name) ON TABLE s FROM PUBLIC;`

### 视图

视图是一个虚拟表

创建语句

```sql
CREATE VIEW <视图名>[(列名序列)] AS SELECT 查询子句 [WITH CHECK OPTION]
```

- 子查询可以是任意复杂的 SELECT 语句，但通常不允许含有 ORDER BY 子句和 DISTINCT 关键字
- WITH CHECK OPTION 表示对 UPDATE、INSERT、DELETE操作时保证更新、插入或删除的行满足视图定义中的谓语条件（即子查询中的条件表达式）
- 视图的属性列名或全部指定，或全部省略（由子查询目标列确定）

删除语句

```sql
DROP VIEW <视图名>
```

### 索引

- 通过建立唯一索引，可以保证数据记录的唯一性
- 可以大大加快数据的检索速度
- 可以加速表与表之间的连接，对数据的参照完整性具有特别意义
- 可以显著减少查询中分组和排序的时间
- 可以在检索数据过程中使用优化隐藏器，提高系统性能
- 类型
  - 聚集索引
    - 索引表中索引项的顺序与表中记录的物理顺序一致，如主键
  - 非聚集索引
    - 如非主键索引，唯一约束

建立索引

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名>(<列名>[ <排序>][, <列名>[ <排序>]]...);
```

- 排序：可选 ASC（升序， 默认） / DSC（降序）
- UNIQUE：表明该索引的每一个索引值只对应唯一的数据记录
- CLUSTER：表明建立聚簇索引（聚集索引），即索引项顺序与表中记录物理顺序一致

删除索引

```sql
DROP INDEX <视图名>
```

> 对索引的处理改变的是数据库三级模式/两级映像结构中的内模式

## 关系模式

定义1

一个关系模式应当是一个五元组（含关系名），即 R<U, D, dom, F>，其中：

1. R 为关系名，是符号化的元组语义
2. U 为一组属性
3. 属性组 U 中的属性来自域 D
4. dom 为属性到域的映射
5. F 为属性组 U 上的一组数据依赖

由于 3 和 4，即 D 和 dom 对模式设计关系不大，因此通常把关系模式看作是一个三元组，即 R<U, F>，当且仅当 U 上的一个关系 r 满足 F 时，r 称为关系模式 R<U, F> 的一个关系

## 函数依赖

函数依赖是一种最重要、最基本的数据依赖

**函数依赖**：

设 R(U) 是属性集 U 上的关系模式，X、Y 是 U 的子集。若对 R(U) 的任何一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数决定 Y，或 Y 函数依赖于 X，记作 $X \rightarrow Y$。

- 非平凡的函数依赖：
  - 如果 $X \rightarrow Y$，但 $Y \nsubseteq X$，则称 $X \rightarrow Y$ 是非平凡的函数依赖。一般情况下总是讨论非平凡的函数依赖。
- 平凡的函数依赖：
  - 如果 $X \rightarrow Y$，但 $Y \subseteq X$，则称 $X \rightarrow Y$ 是平凡的函数依赖。
- 完全函数依赖：
  - 在 R(U) 中，如果 $X \rightarrow Y$，并且对于 X 的任何一个真子集 X' 都有 X' 不能决定 Y，则称 Y 对 X 完全函数依赖，记作 $X\xrightarrow{f}Y$。
- 部分函数依赖：
  - 如果 $X \rightarrow Y$，但 Y 不完全函数依赖于 X，则称 Y 对 X 部分函数依赖，记作 $X\xrightarrow{p}Y$，也称局部函数依赖。
- 传递依赖：
  - 在 R(U) 中，如果 $X \rightarrow Y$，$Y \nsubseteq X$，$Y \rightarrow Z$，则称 Z 对 X 传递依赖。

**码**：

设 K 为 R(U,F) 中属性的组合，若 $K \rightarrow U$，且对于 K 的任何一个真子集 K' 都有 K' 不能决定 U，即 $K\xrightarrow{f}U$，则 K 为 R 的候选码，也称候选关键字。若有多个候选码，则选一个作为主码。

**主属性**：

包含在任何一个候选码中的属性称为主属性，否则称为非主属性。

**外码**：

若 R(U) 中的属性或属性组 X 非 R 的码，但 X 是另一个关系的码，则称 X 为外码。

### 函数依赖的公理系统(Armstrong公理系统)

设关系模式 R(U,F)，其中 U 为属性集，F 是 U 上的一组函数依赖，那么有以下推理规则：

- A1自反律：若 $Y \nsubseteq X \nsubseteq U$，则 $X \rightarrow Y$ 为 F 所蕴涵。
- A2增广律：若 $X \rightarrow Y$ 为 F 所蕴涵，且 $Z \nsubseteq U$，则 $XZ \rightarrow YZ$ 为 F 所蕴涵。
- A3传递律：若 $X \rightarrow Y$，$Y \rightarrow Z$ 为 F 所蕴涵，则 $X \rightarrow Z$ 为 F 所蕴涵。

有上述3条推理规则又可推出下述3条推理规则：

- 合并规则：若 $X \rightarrow Y$，$X \rightarrow Z$ 为 F 所蕴涵，则 $X \rightarrow YZ$ 为 F 所蕴涵。
- 伪传递律：若 $X \rightarrow Y$，$WY \rightarrow Z$ 为 F 所蕴涵，则 $XW \rightarrow Z$ 为 F 所蕴涵。
- 分解规则：若 $X \rightarrow Y$，$Z \subseteq Y$，则 $X \rightarrow Z$ 为 F 所蕴涵。

### 属性闭包计算

给定 R(U,F)，求候选码的过程。

**例一**：

给定关系 R(U,F)，其中 U={A,B,C,D,E,H}，F={A➔B,B➔DH,A➔H,C➔E}，求闭包。

标准解法：

$(A)^+→(ABH)^+→(ABDH)^+→(ABDH)≠U \\
(AC)^+→(ABHCE)^+→(ABDHCE)^+→(ABDHCE)=U，所以闭包为 AC$

> 快速解法：
>
> 排除所有箭头右侧（依赖其他属性）的属性，剩下的属性组合一定包含在候选码中。  
> 使用该方法确定部分主属性，再使用标准解法求解，可以加快求解过程。
> 如本题就可以直接从 (AC) 开始求解。

**例二**：

假设关系 R(U,F)，其中 U={A,B,C,D}，F={A➔BC,AC➔D,B➔D}，求闭包。

箭头右侧属性有 BCD，排除后剩下属性为 A

$(A)^+→(ABC)^+→(ABCD)^+→(ABCD)=U，所以候选码为 A$

**例三**：

假设关系 R(U,F)，其中 U={A₁,A₂,A₃}，F={A₁A₃➔A₂,A₁A₂➔A₃}，求闭包。

箭头右侧属性有 A₂A₃，排除后剩下属性为 A₁

$(A₁)^+→(A₁)≠U \\
(A₁A₂)^+→(A₁A₂A₃)^+→(A₁A₂A₃)=U \\
(A₁A₃)^+→(A₁A₃A₂)^+→(A₁A₃A₂)=U \\
所以有 2 个候选码，分别为 A₁A₂ 和 A₁A₃$
