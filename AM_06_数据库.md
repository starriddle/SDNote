# 上午题 06 数据库

<!-- TOC -->

- [上午题 06 数据库](#上午题-06-数据库)
  - [说明](#说明)
  - [概念数据模型](#概念数据模型)
  - [结构数据模型](#结构数据模型)
  - [三级模式结构](#三级模式结构)
  - [关系模型的基本术语](#关系模型的基本术语)
  - [关系模型定义](#关系模型定义)
    - [关系数据结构](#关系数据结构)
    - [关系操作集合](#关系操作集合)
    - [完整性约束](#完整性约束)
  - [关系代数](#关系代数)
  - [关系代数转SQL语言](#关系代数转sql语言)
  - [SQL语言概述](#sql语言概述)
    - [数据定义语言](#数据定义语言)
    - [数据操纵语言](#数据操纵语言)
    - [数据查询语言](#数据查询语言)
      - [投影查询](#投影查询)
      - [选择查询](#选择查询)
      - [排序查询](#排序查询)
      - [聚合函数](#聚合函数)
      - [数据分组](#数据分组)
      - [连接查询](#连接查询)
        - [内连接](#内连接)
        - [外连接](#外连接)
      - [一般子查询](#一般子查询)
        - [一般子查询](#一般子查询-1)
        - [相关子查询](#相关子查询)
        - [EXISTS子查询](#exists子查询)
      - [查询结果并、交、差运算](#查询结果并交差运算)
    - [SQL控制语句](#sql控制语句)
    - [视图](#视图)
    - [索引](#索引)
  - [关系模式](#关系模式)
  - [函数依赖](#函数依赖)
    - [函数依赖的公理系统(Armstrong公理系统)](#函数依赖的公理系统armstrong公理系统)
    - [属性闭包计算](#属性闭包计算)
  - [关系模式的范式](#关系模式的范式)
    - [码](#码)
    - [第一范式](#第一范式)
    - [第二范式](#第二范式)
    - [第三范式](#第三范式)
    - [BC范式](#bc范式)
    - [第四范式](#第四范式)
    - [关系模式的分解](#关系模式的分解)
      - [无损连接](#无损连接)
      - [保持函数依赖](#保持函数依赖)
  - [数据库设计](#数据库设计)
    - [需求分析阶段](#需求分析阶段)
    - [E-R 模型](#e-r-模型)
      - [括充的 E-R 模型](#括充的-e-r-模型)
    - [概念结构设计](#概念结构设计)
    - [逻辑结构设计](#逻辑结构设计)
    - [物理设计阶段和实施与维护](#物理设计阶段和实施与维护)
  - [数据库的控制功能：事务管理](#数据库的控制功能事务管理)
  - [数据库备份与恢复](#数据库备份与恢复)
  - [并发控制 封锁](#并发控制-封锁)
  - [分布式数据库](#分布式数据库)

<!-- /TOC -->

## 说明

- 分值：6分
- 分布：51-56

教程 9 数据库基础知识 P455-P516

关系代数
SQL语言
关系模式
范式
关系分解：无损连接、函数依赖

- 数据模型分类
  - 概念数据模型
  - 结构数据模型

## 概念数据模型

常用术语

- 实体：客观存在并可以相互区别的事物称为实体
- 属性：描述实体的特性称为属性，一个实体可以由若干个属性来刻画
- 码：唯一标识实体的属性集称为码
- 域：属性的取值范围称为该属性的域
- 实体型：具有相同属性的实体必然具有共同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体，称为实体型
- 实体集：同型实体的集合称为实体集
- 联系：实体（型）之间的对应关系称为联系
  - 实体内部各属性之间的联系
  - 实体之间的联系
  - 实体型之间的联系类型：
    - 一对一联系（1:1）
    - 一对多联系（1:n）
    - 多对多联系（m:n）

实体-联系方法表示的概念数据模型称为 E-R 图

E-R 图是抽象和描述现实世界的有力工具，它提供了表示实体型、属性和联系的方法

实体型 - 矩形
属性 - 椭圆形
联系 - 菱形

## 结构数据模型

- 结构数据模型是直接面向数据库的逻辑结构
- 任何一个DBMS都以某个结构数据模型为基础
- 常用术语
  - 数据项/字段：
    - 数据库中可以命名的最小逻辑数据单位
    - 可以是一个数或一个字符串，用它描述属性的数据
  - 记录：
    - 数据项的有序集
    - 一个记录是由若干个数据项或字段组成，用它描述实体
  - 文件：
    - 一个具有符号名的一组同类记录的集合
    - 文件包含了记录的结构和记录的值
- 分类
  - 层次模型
    - 用“树结构”表示数据之间的联系
    - 数据库系统最早使用的模型
    - 数据结构是一棵“有向树”
    - 特征：
      - 有且仅有一个结点没有父结点，它就是根结点
      - 其他结点有且仅有一个父结点
  - 网状模型
    - 用“图结构”表示数据之间的联系
    - 网中的每一个结点代表一个记录型，联系用链接指针来实现
    - 特征：
      - 允许结点有多于一个的父结点
      - 可以有一个以上的结点没有父结点
  - 关系模型
    - 用二维表格结构来表示实体以及实体之间联系
    - 每个二维表由行、列组成，又可称为关系，关系模式是对关系的描述
    - 关系模型是由关系模式组成的集合
    - 目前主流的数据模型，大多数数据库管理系统都是关系型的
    - 特征：
      - 描述的一致性，不仅用关系描述实体本身，而且也用关系描述实体之间的联系
      - 可直接表示多对多的联系
      - 关系必须是规范化的关系，即每个属性是不可分的数据项，不允许表中有表
      - 关系模型是建立在数学概念基础上的，有较强的理论根据
    - 关系模型中，基本数据结构就是二维表
    - 记录之间的联系通过不同关系中的同名属性来体现
  - 面向对象模型

## 三级模式结构

不同的数据库，建立在不同的操作系统上，使用不同的数据库语言，支持不同的数据模型，数据的存储结构也各不相同，但体系结构基本上都具有相同的特征，采用“三级模式和两级映像”。

**三级模式结构**：数据库管理系统内部的系统结构

- 概念模式
  - 也称 模式
  - 是 数据库中全体数据的逻辑结构和特征的描述
  - 由若干个概念记录类型组成，只涉及型的描述，不涉及具体的值
  - 对应“基本表”
- 外模式
  - 也称 用户模式/子模式
  - 是 用户与数据库系统的接口
  - 是用户用到的那部分数据的描述，由若干个外部记录类型组成
  - 对应“视图”
- 内模式
  - 也称 存储模式
  - 是 数据物理结构和存储方式的描述
  - 是数据在数据库内部的表示方式，定义所有的内部记录类型、索引和文件的组织方式以及数据控制方面的细节
  - 对应“存储文件”

**两级映像**：数据库系统在三级模式之间提供了两级映像

- 模式/内模式映像
  - 该映像存在于 概念级和内部级 之间，实现了 概念模式到内模式 之间的相互转换。
  - 物理独立性
- 外模式/模式映像
  - 该映像存在于 外部级和概念级 之间，实现了 外模式到概念模式 之间的相互转换。
  - 逻辑独立性

## 关系模型的基本术语

关系数据库系统是支持关系模型的数据库系统，关系模型的一些基本术语：

- 关系：一个关系就是一张二维表，每个关系有一个关系名
- 元组：表中的一行即为一个元组，对应存储文件中的一个记录值。
- 属性：表中的列称为属性，每一列有一个属性名。属性值相当于记录中的数据项或者字段值。
- 域：属性的取值范围。
- 关系模式：对关系的描述称为关系模式，由关系名和其属性集合构成。
  - 关系模式的格式为：`关系名(属性名1,属性名2,...,属性名n)`
  - 通常一个关系模式对应一个关系文件的结构
- 候选码(候选键)：属性或属性组合，其值能够唯一地标识一个元组。
- 主码(主键)：在一个关系中可能有多个候选码，从中选择一个作为主码。
- 主属性：包含在任何候选码中的诸属性称为主属性，不包含在任何候选码中的诸属性称为非码属性
- 外码(或外键)：如果一个关系中的属性或属性组并非该关系(二维表)的码，但它们是另外一个关系(二维表)的码，则称其为该关系的外码。
- 全码：关系模式的所有属性组是这个关系模式的候选码，称为全码。
- 超码(超键)：一个包含码的属性集称为超码。

## 关系模型定义

关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成

### 关系数据结构

关系模型中数据的逻辑关系是一张二维表格

### 关系操作集合

常用关系操作：选择、投影、连接、除、并、交、差等查询操作和增加、删除操作等

### 完整性约束

完整性规则保证用户对数据库做修改时不会破坏数据的一致性。

- 实体完整性：关系中主码的值不能为空或部分为空。即主属性不能为空。
- 参照完整性：如果关系R2的外码X与关系R1的主码相对应，则外码X的每个值必须在关系R1中的主码中找到，或者为空值。
- 用户定义完整性：指用户对某一具体数据指定的约束条件进行检验。(如手机号码为11位)

## 关系代数

集合的笛卡尔积：D₁×D₂×...×Dₙ = {(d₁,d₂,...,dₙ)|dᵢ∈Dᵢ,i=1,2,...,n}

![alt text](./AM_06_01.png)

- 传统的集合运算
  - 关系的并：关系R、S的所有元组合并，删去重复的的元组，组成一个新关系
  - 关系的差：关系R、S的差由属于R而不属于S的所有元组组成的集合
  - 关系的交：关系R、S的交由既属于R又属于S的所有元组组成的集合
  - 笛卡尔积：类似于集合的笛卡尔积，关系的元组代替集合的元素
- 专门的关系运算符
  - 投影(Projection)：从关系的垂直方向进行运算，在关系R中选择出若干属性列A组成新的关系。记作πᴀ(R)={t[A]|t∈R}
  - 选择(Selection)：从关系的水平方向进行运算，从关系R中选择满足给定条件的的元组，记作σꜰ(R)={t|t∈R 并且 F(t)=True}
  - 连接(Join)：从两个关系R和S的笛卡儿积中选取满足条件的元组。
    - θ连接：从R与S的笛卡儿积中选取属性间满足一定条件的元组。
    - 等值连接：当 θ 为 “=” 时，称之为等值连接。
    - 自然连接 ⋈：自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果集中将重复属性列去掉。
    > 可以认为笛卡儿积是无条件连接，其他的连接操作认为是有条件连接。
  - 外连接(Outer Join)：外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息。(p27集)
    - 左外连接(Left Outer Join ⟕)：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值null充填所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中。
    - 右外连接( Right Outer Join ⟖)：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值null填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中。
    - 全外连接(Full Outer Join ⟗)：完成左外连接和右外连接的操作。即填充左侧关系中所有与右侧关系中任一元组都不匹配的元组，并填充右侧关系中所有与左侧关系中任一元组都不匹配的元组，将产生的新元组加入自然连接的结果中。
  - 除(Division)：同时从关系的水平方向和垂直方向进行运算。给定关系R(X,Y)和S(Y,Z),X、Y、Z为属性组，R÷S应当满足元组在X上的分量值x的象集Yₓ包含关系S在属性组Y上的投影的集合。

## 关系代数转SQL语言

> SQL 语言不支持列的序号

给定关系 R(A,B,C) 和 S(B,C,D)

- 投影
  - πᴀ(R)={t[A]|t∈R}
  - select A from R
- 选择
  - σꜰ(R)={t|t∈R 并且 F(t)=True}
  - select A,B,C from R where F(t)=True
- 笛卡尔积
  - π(R×S)
  - select R.A,R.B,R.C,S.B,S.C,S.D from R,S
- 自然连接
  - $R⋈S = π_{R.A,R.B,R.C,S.D}(σ_{R.B=S.B∧R.C=S.C}(R×S))$
  - select R.A,R.B,R.C,S.D from R,S where R.B=S.B and R.C=S.C

## SQL语言概述

**特点**：

- 类似于英语自然语言、简单易学
- 一种非过程语言
- 一种面向集合的语言
- 既可独立使用，又可嵌入到宿主语言中使用
- 具有查询、操纵、定义和控制一体化功能

**SQL Server 数据库体系结构**：

- 由视图、基本表和存储文件三级结构组成
  - 即外模式、概念模式、内模式
- 一个数据库是表的汇集，它用一个关系模型定义一个基本表或视图
- 基本表是存储在数据库中的表，视图是由若干个基本表或其他视图构成的表，称为虚表
- 一个基本表可以跨一个或多个存储文件，一个存储文件可以存放一个或多个基本表
- 每个存储文件与外部存储器上的一个物理文件对应

**SQL 语言分类**：

- DDL
  - 数据定义语言，Data Definition Language
  - 建立、修改、删除数据库对象(数据库、表、视图、索引等)
  - CREATE、ALTER、DROP 等
- DML
  - 数据操纵语言，Data Manipulation Language
  - 添加、修改、删除数据库数据
  - INSERT、UPDATE、DELETE 等
- DQL
  - 数据查询语言，Data Query Langague
  - 查询数据库数据，是数据库的基本功能
  - SELECT
- DCL
  - 数据控制语言，Data Control Language
  - 包括数据库对象的权限管理和事务管理等

### 数据定义语言

建立数据库

```sql
CREATE DATABASE <数据库名>
```

建立基本表

```sql
CREATE TABLE <表名>(
  <列名> <数据类型> [列级完整性约束条件]
  [,<列名> <数据类型> [列级完整性约束条件]]...
  [,表级完整性约束条件]...
);
```

- 完整性约束
  - 主要有3种子句：
    - 主键子句(PRIMARY KEY)
      - 实体完整性
    - 检查子句(CHECK)
      - 用户自定义完整性
    - 外键子句(FOREIGN KEY)
      - 参照完整性
  - 其他
    - 非空：NOT NULL
    - 唯一：UNIQUE
    - 默认值：DEFAULT

修改基本表结构

```sql
-- 增加新列
ALTER TABLE <表名> ADD <列名> <数据类型> [列级完整性约束条件]

-- 修改新列
ALTER TABLE <表名> MODIFY <列名> <新数据类型>

-- 删除列
ALTER TABLE <表名> DROP <完整性约束名>
```

删除基本表

```sql
DROP TABLE <表名>
```

### 数据操纵语言

插入

```sql
INSERT INTO <表名>(列名序列) VALUES(元组值)
INSERT INTO <表名>(列名序列) SELECT 查询语句
```

删除

```sql
DELETE FROM <表名> [WHERE 条件表达式]
```

修改

```sql
UPDATE <表名> SET <列名>=值表达式[, <列名>=值表达式]... [WHERE 条件表达式]
```

### 数据查询语言

SELECT 语句

```sql
SELECT [ALL|DISTINCT] <目标列表达式>[, <目标列表达式>]...
FROM <表名>[, <表名>]
[WHERE <条件表达式>]
[GROUP BY <列名1> [HAVING <条件表达式>]]
[ORDER BY <列名2> [ASC|DESC]...]
```

#### 投影查询

- SELECT 子句可以选则查询表中的任意列
- FROM 子句指明从什么表中提取数据
- DISTINCT 去重：去除重复的显示数据行
- AS 别名关键字：<列名> AS <别名>

#### 选择查询

- 指定查询条件，只从源表提取满足该查询条件的记录
- WHERE 子句的行条件表达式指出记录应满足的条件
- 运算类型
  - 条件表达式的比较运算
  - 字符串的匹配运算：`[NOT] LIKE <匹配串>`
    - %：代表任意长度的字符串
    - _：代表任意单个字符
  - 集合的比较运算：条件表达式中包含集合成员运算符
  - 逻辑组合运算：条件表达式中包含多个条件子句，通过逻辑运算符组合

#### 排序查询

- 使用 ORDER BY 子句来控制选择行的显示顺序
- ORDER BY 子句必须是 SELECT 语句中的最后一个子句

#### 聚合函数

- 实现数据统计等功能
  - 对一组值进行计算并返回一个单一的值
- 在 select 子句中的 目标列表达式 中使用
- 通常与 group by 子句一起使用，对每个分组进行数据统计
  - 无 GROUP BY 子句，聚合函数的作用范围是满足 WHERE 子句条件的所有记录
  - 有 GROUP BY 子句，聚合函数的作用范围是对结果进行分组后每组的所有记录
- 聚合函数参数一般格式：`[ALL|DISTINCT] expr`，默认为 `ALL`

#### 数据分组

- 使用 GROUP BY 子句把查询结果按指定列分成集合组
- 使用 HAVING 子句定义这些组必须满足的条件，满足条件的分组才会出现在结果中
- WHERE + GROUP BY + HAVING + 聚合函数
  - 执行 WHERE 子句，提取符合条件的记录
  - 执行 GROUP BY 子句，对记录进行分组
  - 执行聚合函数
  - 执行 HAVING 子句，筛选符合条件的分组

#### 连接查询

一个查询中需要对多个表连接时，可以指定连接列，在 WHERE 子句中给出连接条件，在 FROM 子句中指定要连接的表

```sql
SELECT 列名1, 列名2, ... FROM 表1, 表2, ... WHERE 连接条件 AND 查询条件
```

连接分为内连接（INNER JOIN）和外连接（OUTER JOIN），一般的连接查询（不使用关键字）默认为内连接

##### 内连接

最基本的连接方式

```sql
SELECT 列名1, 列名2, ... FROM 表1 INNER JOIN 表2 ON 连接条件 WHERE 查询条件
```

- 等值连接
  - 表之间通过等于关系连接起来，产生一个连接临时表，进行处理并生成结果
- 非等值连接
  - 表之间的连接关系不是等于，而是其他关系
- 自连接
  - 将同一个表进行连接，如同两个分开的表一样，将同一个表的不同行连接起来

##### 外连接

```sql
SELECT 列名1, 列名2, ... FROM 表1 (LEFT|RIGHT|FULL) [OUTER] JOIN 表2 ON 连接条件 WHERE 查询条件
```

- 左外连接
  - 左连接的结果包括表1所有行，不包括表2中的不匹配行
- 右外连接
  - 右连接的结果包括表2所有行，不包括表1中的不匹配行
- 全外连接
  - 全连接的结果包括2个表的所有行，即包括2个表中的所有不匹配行

#### 一般子查询

当一个查询是另一个查询的条件时，即当从表中选取数据行的条件依赖于该表本身或其他表的联合信息时，需要使用子查询来实现。

子查询可以使用几个简单命令构造功能强大的复杂命令。

子查询常用于 SELECT 语句的 WHERE 子句中，即在一个 SELECT 语句的 WHERE 子句中嵌套另一个 SELECT 语句。

##### 一般子查询

- 每个子查询仅执行一次
- 子查询独立完成，与主查询无关
- 子查询返回值由主查询的 WHERE 子句所用

##### 相关子查询

内层的查询条件涉及到外层属性的子查询，称为相关子查询

- 子查询不止执行一次，在主查询判断每一行时，都会唤醒子查询
- 主查询会将当前行的某些属性提交给子查询，用于子查询的查询条件
- 子查询返回值提交给主查询，用于判断当前行是否满足条件
- 相关子查询比较费时，不建议对较大的表使用

##### EXISTS子查询

- 在子查询中使用 EXISTS 关键字，其后紧跟一个 SELECT 子查询
  - 子查询一般用在 WHERE 子句中
  - EXISTS 代表存在量词
- 带有 EXISTS 谓词的子查询不返回任何数据，只返回逻辑真和假
  - 当子查询结果不为空集时返回逻辑真，否则返回逻辑假

#### 查询结果并、交、差运算

可以使用以下运算符将多个 SELECT 语句的结果进行相应运算：

- 运算符：
  - UNION：并
  - INTERSECT：交
  - EXCEPT：差
- 说明：
  - 用于运算的所个 SELECT 语句的结果列必须一致
  - 整个语句最后的 ORDER BY 子句可对运算结果进行排序

### SQL控制语句

- 数据控制控制的是用户对数据的存储权利，是由DBA决定的
- 某个用户对某类数据具有何种权力，是个政策问题，而非技术问题，基于安全性
- DBMS的功能是保证这些决定的执行，因此 DBMS 数据控制应具有以下功能
  - 通过 GRANT 和 REVOKE 将授权通知系统，存入数据字典
  - 当用户提出请求时，根据授权情况检查是否执行操作请求

授权

```sql
GRANT <权限1>[(<列1>[,<列2>]...)][,<权限2>[(<列1>[,<列2>]...)]]... [ON <对象类型> <对象名>] TO (PUBLIC|<用户1>[,<用户2>]...) [WITH GRANT OPTION]
```

收回权限

```sql
REVOKE <权限1>[(<列1>[,<列2>]...)][,<权限2>[(<列1>[,<列2>]...)]]... [ON <对象类型> <对象名>] FROM (PUBLIC|<用户1>[,<用户2>]...)
```

常见操作权限（不同类型的操作对象有不同的操作权限）

|  对象  | 对象类型 | 操作权限                                                                     |
| :----: | :------: | ---------------------------------------------------------------------------- |
| 属性列 |  TABLE   | SELECT, INSERT,UPDATE, DELETE, ALL PRIVILEGES（4种权限的总和）               |
|  视图  |  TABLE   | SELECT, INSERT,UPDATE, DELETE, ALL PRIVILEGES（4种权限的总和）               |
| 基本表 |  TABLE   | SELECT, INSERT,UPDATE, DELETE, ALTER, INDEX, ALL PRIVILEGES（6种权限的总和） |
| 数据库 | DATABASE | CREATETAB 建立表的权限，可由 DBA 授予普通用户                                |

说明

- PUBLIC：接收权限的用户可以是单个或多个具体的用户，PUBLIC 参数可将权限赋予全体用户
- WITH GRANT OPTION：获得了权限的用户还可以使用 GRANT 语句将所得权限赋予其他用户
- 对属性列的操作权限进行授权/收回时，指定属性列需要紧接在指定权限后
  - 例：`REVOKE UPDATE(no, name) ON TABLE s FROM PUBLIC;`

### 视图

视图是一个虚拟表

创建语句

```sql
CREATE VIEW <视图名>[(列名序列)] AS SELECT 查询子句 [WITH CHECK OPTION]
```

- 子查询可以是任意复杂的 SELECT 语句，但通常不允许含有 ORDER BY 子句和 DISTINCT 关键字
- WITH CHECK OPTION 表示对 UPDATE、INSERT、DELETE操作时保证更新、插入或删除的行满足视图定义中的谓语条件（即子查询中的条件表达式）
- 视图的属性列名或全部指定，或全部省略（由子查询目标列确定）

删除语句

```sql
DROP VIEW <视图名>
```

### 索引

- 通过建立唯一索引，可以保证数据记录的唯一性
- 可以大大加快数据的检索速度
- 可以加速表与表之间的连接，对数据的参照完整性具有特别意义
- 可以显著减少查询中分组和排序的时间
- 可以在检索数据过程中使用优化隐藏器，提高系统性能
- 类型
  - 聚集索引
    - 索引表中索引项的顺序与表中记录的物理顺序一致，如主键
  - 非聚集索引
    - 如非主键索引，唯一约束

建立索引

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名>(<列名>[ <排序>][, <列名>[ <排序>]]...);
```

- 排序：可选 ASC（升序， 默认） / DSC（降序）
- UNIQUE：表明该索引的每一个索引值只对应唯一的数据记录
- CLUSTER：表明建立聚簇索引（聚集索引），即索引项顺序与表中记录物理顺序一致

删除索引

```sql
DROP INDEX <视图名>
```

> 对索引的处理改变的是数据库三级模式/两级映像结构中的内模式

## 关系模式

定义1

一个关系模式应当是一个五元组（含关系名），即 R<U, D, dom, F>，其中：

1. R 为关系名，是符号化的元组语义
2. U 为一组属性
3. 属性组 U 中的属性来自域 D
4. dom 为属性到域的映射
5. F 为属性组 U 上的一组数据依赖

由于 3 和 4，即 D 和 dom 对模式设计关系不大，因此通常把关系模式看作是一个三元组，即 R<U, F>，当且仅当 U 上的一个关系 r 满足 F 时，r 称为关系模式 R<U, F> 的一个关系

## 函数依赖

函数依赖是一种最重要、最基本的数据依赖

**函数依赖**：

设 R(U) 是属性集 U 上的关系模式，X、Y 是 U 的子集。若对 R(U) 的任何一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数决定 Y，或 Y 函数依赖于 X，记作 $X \rightarrow Y$。

- 非平凡的函数依赖：
  - 如果 $X \rightarrow Y$，但 $Y \nsubseteq X$，则称 $X \rightarrow Y$ 是非平凡的函数依赖。一般情况下总是讨论非平凡的函数依赖。
- 平凡的函数依赖：
  - 如果 $X \rightarrow Y$，但 $Y \subseteq X$，则称 $X \rightarrow Y$ 是平凡的函数依赖。
- 完全函数依赖：
  - 在 R(U) 中，如果 $X \rightarrow Y$，并且对于 X 的任何一个真子集 X' 都有 X' 不能决定 Y，则称 Y 对 X 完全函数依赖，记作 $X\xrightarrow{f}Y$。
- 部分函数依赖：
  - 如果 $X \rightarrow Y$，但 Y 不完全函数依赖于 X，则称 Y 对 X 部分函数依赖，记作 $X\xrightarrow{p}Y$，也称局部函数依赖。
- 传递依赖：
  - 在 R(U) 中，如果 $X \rightarrow Y$，$Y \nsubseteq X$，$Y \rightarrow Z$，则称 Z 对 X 传递依赖。

**码**：

设 K 为 R(U,F) 中属性的组合，若 $K \rightarrow U$，且对于 K 的任何一个真子集 K' 都有 K' 不能决定 U，即 $K\xrightarrow{f}U$，则 K 为 R 的候选码，也称候选关键字。若有多个候选码，则选一个作为主码。

**主属性**：

包含在任何一个候选码中的属性称为主属性，否则称为非主属性。

**外码**：

若 R(U) 中的属性或属性组 X 非 R 的码，但 X 是另一个关系的码，则称 X 为外码。

### 函数依赖的公理系统(Armstrong公理系统)

设关系模式 R(U,F)，其中 U 为属性集，F 是 U 上的一组函数依赖，那么有以下推理规则：

- A1自反律：若 $Y \nsubseteq X \nsubseteq U$，则 $X \rightarrow Y$ 为 F 所蕴涵。
- A2增广律：若 $X \rightarrow Y$ 为 F 所蕴涵，且 $Z \nsubseteq U$，则 $XZ \rightarrow YZ$ 为 F 所蕴涵。
- A3传递律：若 $X \rightarrow Y$，$Y \rightarrow Z$ 为 F 所蕴涵，则 $X \rightarrow Z$ 为 F 所蕴涵。

有上述3条推理规则又可推出下述3条推理规则：

- 合并规则：若 $X \rightarrow Y$，$X \rightarrow Z$ 为 F 所蕴涵，则 $X \rightarrow YZ$ 为 F 所蕴涵。
- 伪传递律：若 $X \rightarrow Y$，$WY \rightarrow Z$ 为 F 所蕴涵，则 $XW \rightarrow Z$ 为 F 所蕴涵。
- 分解规则：若 $X \rightarrow Y$，$Z \subseteq Y$，则 $X \rightarrow Z$ 为 F 所蕴涵。

### 属性闭包计算

给定 R(U,F)，求候选码的过程。

**例一**：

给定关系 R(U,F)，其中 U={A,B,C,D,E,H}，F={A➔B,B➔DH,A➔H,C➔E}，求闭包。

标准解法：

$(A)^+→(ABH)^+→(ABDH)^+→(ABDH)≠U \\
(AC)^+→(ABHCE)^+→(ABDHCE)^+→(ABDHCE)=U，所以闭包为 AC$

> 快速解法：
>
> 排除所有箭头右侧（依赖其他属性）的属性，剩下的属性组合一定包含在候选码中。  
> 使用该方法确定部分主属性，再使用标准解法求解，可以加快求解过程。
> 如本题就可以直接从 (AC) 开始求解。

**例二**：

假设关系 R(U,F)，其中 U={A,B,C,D}，F={A➔BC,AC➔D,B➔D}，求闭包。

箭头右侧属性有 BCD，排除后剩下属性为 A

$(A)^+→(ABC)^+→(ABCD)^+→(ABCD)=U，所以候选码为 A$

**例三**：

假设关系 R(U,F)，其中 U={A₁,A₂,A₃}，F={A₁A₃➔A₂,A₁A₂➔A₃}，求闭包。

箭头右侧属性有 A₂A₃，排除后剩下属性为 A₁

$(A₁)^+→(A₁)≠U \\
(A₁A₂)^+→(A₁A₂A₃)^+→(A₁A₂A₃)=U \\
(A₁A₃)^+→(A₁A₃A₂)^+→(A₁A₃A₂)=U \\
所以有 2 个候选码，分别为 A₁A₂ 和 A₁A₃$

## 关系模式的范式

### 码

**定义**：如果函数依赖 X→U 在 R 上成立，且不存在任何 $X' \sub X$，使得 X'→U 也成立，则称 X 是 R 的一个候选码。

候选码中包含的属性称为主属性，不包含在候选码中的属性称为非主属性。

若有多个候选码，可以选择其中的一个作为主码。

**定义**：关系模式 R 中属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的外码。

关系数据库中的关系必须满足一定的规范化要求，对于不同的规范化程度可用范式来衡量。

范式是符合某一种级别的关系模式的集合，是衡量关系模式规范化程度的标准，达到范式的关系才是规范化的。

$1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF$

一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这个过程称为规范化。

### 第一范式

**定义**：设 R 是一个关系模式，R 属于第一范式当且仅当 R 中每一个属性 A 的值域只包含原子项，即不可分割的数据项。

第一范式不能排除数据冗余和更新异常等问题，因为其中可能存在**部分函数依赖**。

### 第二范式

**定义**：设 R 是一个关系模式，R 属于第二范式当且仅当 R 是第一范式，且每个非主属性都完全函数依赖于候选码。

不属于 2NF 的关系模式 R 会产生插入异常、删除异常和修改复杂等问题。

属于 2NF 的关系模式 R 也可能存在数据冗余和更新异常问题，因为其中可能存在**传递函数依赖**。

### 第三范式

**定义**：设 R 是一个关系模式，R 属于第三范式当且仅当 R 是 2NF，且每个非主属性都非传递函数依赖于候选码。

一个不属于 2NF 的关系模式 R 会产生插入异常、删除异常和修改复杂等问题。

属于 3NF 的关系模式 R 可能存在主属性对码的部分依赖和传递依赖。

### BC范式

**定义**：设 R 是一个关系模式，F 是它的依赖集，R 属于 BCNF 当且仅当其 F 中每个依赖的决定因素必定包含 R 的某个候选码。

由定义可知，一个满足 BCNF 的关系模式有：

- 所有非主属性对每一个码都是完全函数依赖
- 所有主属性对每一个不包含它的码，也是完全函数依赖
- 没有任何属性完全函数依赖于非码的任何一组属性

一个满足 BCNF 的关系模式 R 已消除了插入和删除异常。

### 第四范式

**定义**：设有一个关系模式 R<U,F> 是 1NF，如果对于 R 的每个非平凡多值依赖 $X→→Y (Y \nsubseteq X)$，X 都包含了 R 的一个候选码，则称 R 是第四范式。

**多值依赖**的定义：

- 给定的关系模式 R<U,F>，有 X、Y、Z 是 U 的子集，并且 Z=U-X-Y，关系模式 R 中的**多值依赖 X→→Y** 成立，当且仅当对 R 的任一关系 r，给定一对 (x,z) 值，有一组 Y 的值，这组值仅仅决定于 x 值而与 z 值无关。
- 若以上定义中有 X→→Y 成立，而 $Z=\emptyset$ 即 Z 为空，则称 X→→Y 为平凡的多值依赖

### 关系模式的分解

对存在数据冗余、插入异常、删除异常问题的关系模式，应采取将一个关系模式分解为多个关系模式的方法进行处理，相应的，原来存储在一个二维表内的数据就要分散到多个二维表中，要使这个分解有意义，起码的要求是后者不能丢失前者的信息。

在分解处理中会涉及到一些新问题，为使分解后的模式保持原模式所满足的特性，其基本要求是模式分解具有无损连接性和保持函数依赖性

- 1NF 分解为 2NF
  - 消除非主属性对码的部分函数依赖
- 2NF 分解为 3NF
  - 消除非主属性对码的传递函数依赖
- 3NF 分解为 BCNF
  - 消除主属性对码的部分、传递函数依赖
- BCNF 分解为 4NF
  - 消除非平凡且非函数依赖的多值依赖

#### 无损连接

无损连接性指的是对关系模式分解时，原关系模式下任一合法的关系实例在分解后应能通过自然连接运算恢复起来。

**定义**：设 ρ={R₁<U₁,F₁>, R2<U₂, F₂>,...,Rₖ<Uₖ,Fₖ>} 是关系模式 R<U,F> 的一个分解，如果对于 R 的任一满足 F 的关系 r 都有：$r=π_{R_1}(r)⋈π_{R_2}(r)⋈...⋈π_{R_k}(r)$，则称这个分解 ρ 是满足依赖集 F 的无损连接

如果 R 的分解为 ρ={R₁, R₂}，F 为 R 所满足的函数依赖集合，则分解 ρ 具有无损连接性的充分必要条件为：R₁∩R₂→(R₁-R₂) 或 R₁∩R₂→(R₂-R₁)。

#### 保持函数依赖

设有关系模式 R,F 是 R 的函数依赖集，Z 是 R 的一个属性集合，则称 Z 所涉及到的 $F^+$ 中所有函数依赖为 F 在 Z 上的投影，记为 $π_Z(F)$，有：$π_Z(F)=\lbrace x→y | x→y ∈ F^+ 且 xy\subseteq z \rbrace$。

设关系模式 R 的一个分解 ρ={R₁<U₁,F₁>, R2<U₂, F₂>,...,Rₖ<Uₖ,Fₖ>}，F 是 R 的依赖集，如果 F 等价于 $π_{R_1}(F)∪π_{R_2}(F)∪...∪π_{R_k}(F)$，则称分解 ρ 具有依赖保持性。

一个无损连接分解不一定具有依赖保持性，同样，一个依赖保持性分解不一定具有无损连接性

## 数据库设计

新奥尔良法 4 个主要阶段

1. 用户需求分析：收集用户需求，确定系统边界
2. 概念设计：E-R 图
3. 逻辑设计：E-R图 → 关系模型 → 规范化
4. 物理设计
5. 实施阶段
6. 运行、维护阶段

### 需求分析阶段

项目确定之后，用户和设计人员对数据库应用系统所要涉及的内容（数据）和功能（行为）的整理和描述，即为需求分析，是以用户的角度来认识系统。逻辑设计、物理设计，以及应用程序的设计都以此为依据，是后续开发的基础。

### E-R 模型

概念模型有很多种表示方法，最常见的是 实体-联系方法，用E-R图来描述现实世界的概念模型，称为实体-联系模型。

1. 实体
   - 用矩形表示，矩形框内写明实体名
2. 联系
   - 用菱形表示，菱形框内写明联系名
   - 无向边(线段)连接实体和联系
     - 无向边旁标注联系的类型：1:1、1:n、m:n
   - 实体与实体之间的联系
     - 两个不同实体之间的联系
       - 一对一(1:1)
       - 一对多(1:n)
       - 多对多(m:n)
     - 两个以上不同实体集之间的联系
       - 一对一对一(1:1:1)
       - 一对一对多(1:1:n)
       - 一对多对多(1:m:n)
       - 多对多对多(r:m:n)
   - 实体内部的联系
     - 反映数据在同一记录内部各字段间的联系
     - 同一实体集内的二元联系
       - 一对一(1:1)
       - 一对多(1:n)
       - 多对多(m:n)
3. 属性
   - 实体某方面的特性
   - 用椭圆表示，椭圆框内写明属性名称，主码的名称下添加下划线
   - 分类
     - 简单属性和复合属性
       - 简单属性：原子的，不可再分的，如性别
       - 复合属性：可以细分为更小的部分，如通信地址
     - 单值属性和多值属性
       - 单值属性：一个特定实体该属性只有一个单独值，如编号、姓名
       - 多值属性：一个实体该属性可能有一组值，如亲属姓名
     - NULL 属性：实体某个属性没有值或值未知，表示无意义或不知道
     - 派生属性：可由其他属性得来的属性，如 参加工作时间→工作年限

E-R 图中的主要构件

| 构件       | 说明                                 |
| ---------- | ------------------------------------ |
| 矩形       | 实体集                               |
| 双边矩形   | 弱实体集                             |
| 双竖边矩形 | 子实体集                             |
| 菱形       | 联系集                               |
| 双边菱形   | 弱实体集对应的标识性联系             |
| 椭圆       | 属性                                 |
| 线段       | 连接实体集与联系集，属性与相关实体集 |
| 双椭圆     | 多值属性                             |
| 虚椭圆     | 派生属性                             |
| 双线       | 一个实体全部参与到联系中             |

说明：

- 在 E-R 图中，实体集中作为主码的一部分属性以下划线标明。
- 在实体集与联系的线段上标上联系的类型
- 不引起误解时，实体集有时简称实体，联系集有时简称联系。

#### 括充的 E-R 模型

1. 弱实体

   有一种特殊的联系，代表实体间的所有/所属关系。

   一个实体对于另一个实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提，这类实体称为弱实体。

   如实体 `职工` 与弱实体 `家属` 之间 `1:n` 的 `所属` 关系。

   弱实体用双边矩形表示，框内写明实体名。

2. 特殊化

   某些实体一方面具有一些共性，另一方面还具有各自的特殊性。

   一个实体集可以按照某些特征区分为几个子实体，这种从普通到特殊的过程称为特殊化。

3. 普通化

   将几个具有共同特征的实体集概括成一个更普通的实体集的过程称为普通化。

设有实体集 E，如果 S 是 E 的某些真子集的集合，记为 $S = \lbrace Sᵢ | Sᵢ \subset E, i=1,2,...,n \rbrace$，则称 S 是 E 的一个特殊化， E 是 S₁,S₂,...,Sₙ 的超类，S₁,S₂,...,Sₙ 称为 E 的子类。

如果 $∪_{i=1}^nSᵢ=E$，则称 S 是 E 的全特殊化，否则为部分特殊化。

如果 $Sᵢ∩Sⱼ = \emptyset，i≠j$，则 S 是不相交特殊化，否则是重叠特殊化。

超类-子类关系模型的 E-R 图表示：

- 特殊化圆圈和连线的一般方式：
  - 圆圈表示按照某种特征特殊化为几个子类
    - 不相交特殊化：圆圈中为小写字母 d
    - 重叠特殊化：圆圈中为小写字母 o
  - 连线
    - 连接超类和特殊化圆圈
      - 全特殊化：使用双线
      - 部分特殊化：使用单线
    - 连接子类和特殊化圆圈
      - 带符号 ∪ 的线条，表示特殊化
- 仅用连线的特殊方式
  - 直接用带符号 ∪ 的线条连接超类和子类
    - 表示按某种特征从超类特殊化出一个子类

### 概念结构设计

用 E-R 图方法建立概念模型

- 选择局部应用：选择适当层次的数据流图，使该层数据流图的每一部分对应一个局部应用，实现某一项功能
- 逐一设计分 E-R 图，也称局部 E-R 图
- E-R 图合并：解决分 E-R 图中相互间存在的冲突、信息冗余，成为统一的、精炼的全局概念模型
  - 冲突
    - 属性冲突
    - 命名冲突
    - 结构冲突
  - 优化
    - 实体类型合并
    - 冗余属性消除
    - 冗余联系消除

### 逻辑结构设计

在概念结构设计的基础上进行数据模型设计，可以是层次模型、网状模型、**关系模型**。

- 确定数据模型
- 将 E-R 图转换成为指定的数据模型
  - E-R图转换关系模式
  - 关系模式的规范化
- 确定完整性约束
- 确定用户视图

E-R 图关系模式的转换

- 实体向关系模型的转换
  - 实体名->关系模式的名称
  - 实体属性->关系模式的属性
  - 实体标识符->关系的码(键)
- 联系向关系模型的转换
  - 一对一联系
    - 独立关系模式
      - 联系名称->关系模式名称
      - 关系模式的属性：关联的2个实体的码和联系属性
      - 关系模式的码：任一方实体的码
    - 联系归并到2个实体的任一方
      - 将一方实体的码和联系属性增加到另一方实体的属性集中
  - 一对多联系
    - 独立关系模式
      - 联系名称->关系模式名称
      - 关系模式的属性：关联的2个实体的码和联系的属性
      - 关系的码：多方实体的码
    - 联系归并到2个实体中的多方实体
      - 将一方实体的码和联系属性增加到多方实体的属性中
  - 多对多联系
    - 独立关系模式
      - 关系模式名称：联系名称
      - 关系模式属性：关联的2个实体的码和联系属性
      - 关系模型的码：2个多方实体的码构成的属性组

### 物理设计阶段和实施与维护

## 数据库的控制功能：事务管理

事务是一个操作序列，是数据库环境中不可分割的逻辑工作单位。

- 事务定义语句
  - BEGIN TRANSACTION
    - 事务开始
  - COMMIT
    - 事务提交
  - ROLLBACK
    - 事务回滚
- 事务特性
  - 原子性 Atomicity
  - 一致性 Consistency
  - 隔离性 Isolation
  - 持久性 Durability

## 数据库备份与恢复

- 故障类型
  - 事务内部故障
  - 系统故障
  - 介质故障
  - 计算机病毒
- 备份方法：建立数据冗余
  - 静态转储和动态转储
  - 海量转储和增量转储
  - 日志文件
- 恢复 步骤
  - 反向扫描日志文件，查找该事务的更新操作
  - 对事务的更新操作执行逆操作
  - 继续反向扫描日志文件，查找该事务的其他更新操作，并作同样地处理，知道事务的开始标志。
- 数据库镜像
  - 避免磁盘介质出现故障影响数据库的可用性，提供数据库镜像功能用于恢复
  - 通过复制数据实现，频繁复制数据会降低系统运行效率
  - 对关键的数据和日志文件镜像

## 并发控制 封锁

并发操作：在多用户共享的系统中需多用户可能同时对同一数据进行操作。

并发操作带来的问题是**数据的不一致性**（**丢失修改**、**不可重复读**、**读脏数据**），主要原因是事务的并发操作破坏了**事务的隔离性**。

并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，避免用户得到不正确的数据。

并发控制的主要技术是 **封锁**

- 封锁：并发控制的主要技术
  - 排他锁：写锁、X锁
    - 只允许当前事务读写，禁止其他事务加任何锁
  - 共享锁：读锁、S锁
    - 只允许当前事务读取，不能修改；只允许其他事务加共享锁
    - 数据有共享锁时，允许读，禁止修改，知道所有共享锁结束

## 分布式数据库

- 分片透明：指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的
- 复制透明：指采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的。
- 位置透明：指用户无须知道数据存放的物理位置
- 逻辑透明：指用户或应用程序无需知道局部场地使用的是哪种数据模型
- 共享性：指数据存储在不同的结点数据共享
- 自治性：指每结点对本地数据都能独立管理
- 可用性：指当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪
- 分布性：指数据在不同场地上的存储
